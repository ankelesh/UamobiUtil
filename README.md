#Uamobi Util Documentation##Building and preparingThis project is fully prepared for building on old Qt down to 4.8 and building on new Qt versions up to newest (5.13.2).  To disable compatibility mode (required for Win CE and Win XP builds) define QT_VERSION5X.###Usable flag definitions:QT\_VERSION5X : enables and disables Qt5 only features and includes. Must be defined if your qt version is not 4x.Q\_NULLPTR	"0": this constant must be enabled for QT4 because old cpp standard is lacking _nullptr_.DEBUG	    : this flag enables debugging. It will print all usefull data about program flow into logs. Warning - do not enable this in release version to avoid too big log files.FTR_COM     : this flag enables bluetooth communication with printer. Do not enable it if your release is not meant to use TTY interfaces or is not windows build.###Library and enviroments requiredFor modern systems:QtCreator if this is UamobiUtilCE source package and any installed Qt 5+ lib.Visual Studio with Qt Visual Tools extension for normal Uamobiutil package and any installed Qt 5+ lib.Android:NDK 19-20+ (tested and compiled on 20.55)SDK 26+ (tested and compiled on 26)Windows:Microsoft Visual Studio 2017-19 (compiled on v.142)Windows SDK 10.0 For older systems:QtCreator 3+ and any installed Qt4.8+ library. Use UamobiUtilCE package because of incompatibility with vs2005.WinCE5.0\6.0Microsoft Visual Studio 2005platform supported SDK (usually Windows Mobile SDK 5.0 is fine). If possible, use platform-provided SDK like HONEYWELL D6X00. Qt 4 binaries for this platform. Note that it is impossible to just google them. Options:Virtual machine winxp_dev contains all binaries for wince5\6 in D:\DevYou still can try building Qt for required platform. Sources are located on same VM. ###Building step by step Qt4 for QtCreator. WinCe/WinXp* Open Qt Creator. Export project by opening UamobiUtil.pro file.     * Do not forget, that only UamobiUtilCE source pack has valid .pro file* Assign building kit for the project. Use msvc2005\2008 for WinXp and platform-provided sdk for wince.* Check flags in .pro file. Set INCLUDEPATH += {your qt destination}. Disable QT_VERSION5X.* Build. Do not forget that for proper work you will need visual studio redistributable for your compiler. Qt5 for Visual Studio* Open Visual Studio 2017+    * Install Visual Studio Qt Tools extension    * Add proper version of Qt binaries    * In "project settings" add your qt version destination.     * Check modules _GUI, CORE, WIDGETS, NETWORK, XML_* Check flags in C++ compiler settings. Enable QT_VERSION5X* Build. Do not forget to launch windeployqt.exe after build. Qt5 for QtCreator. Android etc.* Open QtCreator. Export project file.* Assign building kit for target platform    * For android: download Android Studio. In SDK settings select SDK\NDK tools.	* Do not forget to add paths to JRE, NDK at DEVICE settings.    	* Do not forget to choose correct ARM version. Usually armeabi_v7a is ok, sometimes arm64 v8 is required. x86 is rarely used.* Build.#Main construction and architecture notes:This application was concentrated over full crossplatform compatibility. That is why I discourage you of using platform-dependent libraries like <windows.h>. If you desperately need something - hide it under #ifdef.  This application is a client and an interpretator for modes of databases of una.md. It modifies api calls and program flow in case of new modes.##StructureThis application is concentrated over branching structure with dynamic behavior. This means that application has no default behaviour, except screen eplacing policy. Usually it's flow can be described as:  >Login branch - Mode branch - {branch interpreted by mode description}   Interpreting branch happens in interpretMode method of UamobiUtil widget. Branch created there is considered as root one in the tree. It will emplace nodes during the flow with allowing stepping-in subbranches.__inframed widget__  This class is the wrapper for normal QWidget, which provides some usefull interfaces, and has own keyfilter that is usefull for key-navigation over application. It is rarely required.__IndependentBranchNode__This class is the basic object of any dynamically allocated nodes. It provides some interfaces to node and all inframedWidget interfaces.__Global Settings Object__  This singletone object stores data used through all the application.__Element Styles__  In this project is used fully static definition of stylesheets. Header _ElementsStyles.h_ is defining them, and is providing scaling functions. They are creating fonts and sizes using available geometry of main screen.  __legacy__  In header legacy.h are defined some legacy functions that can not be replaced with modern approach. Consider deleting it.__Entities__  For handling inner data were created some classes wrapping default parsing names and frequently used queries. You can use them polymorthically to avoid multiple realisations of list views.__Processing Overlay__  This header provides an overlay window which is counting remaining time, and then autohides. To use it you must bind an overlay object to application root and then use static functions "show\hideProcessingOverlay".__Controls__Most of the times input elements are not fixed. They are sent from server as a pair name-type-default and constructed by factory. abs_control class is providing pure interface, so use it for wrapping more complex widgets. __Scaning__ widget family is only containing fixed amount of controls. ##Network interactionThis application has 3 different layers of connection. First is __DataUpdatengine__.This engine is handling pure packet sending by applying data to provided queries. Queries are usually provided by user . It will attach reply object to provided awaiter. __Network Awaiter__ is the second layer of connection. It usually provides timeout-tracking and one request limitation. It can work both asynchronically or synchronically. You can check it's object if request is awaited, if timeout happened, how much time remains. It's object usually holds both response and error strings from request unitl new request overwrites it. It performs primary parsing of provided object.__Request Parser__ is last connection layer.It generally operates over xml documents received through other layers of connections. It is providing package of interpretAs* functions that are tied to common objects. Any of them can try parsing response and will return parsed structure that is ready for usage.##Debugging and tracing moduleThis project contains debugtrace module that is providing thread-safe engine of writing data in the same log file. Also it provides usefull filtration of prioritized messages. To change it's default behavior you must change construction of static object using init()  Change priority mode to filter out common and annoying debug messages. You can disable it completely by turning max priority - it will just skip messages.