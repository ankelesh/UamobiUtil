#Uamobi Util Documentation##Building and preparingThis project is fully prepared for building on old Qt down to 4.8 and building on new Qt versions up to newest (5.13.2).  To disable compatibility mode (required for Win CE and Win XP builds) define QT_VERSION5X.###Usable flag definitions:QT\_VERSION5X : enables and disables Qt5 only features and includes. Must be defined if your qt version is not 4x.Q\_NULLPTR	"0": this constant must be enabled for QT4 because old cpp standard is lacking _nullptr_.DEBUG	    : this flag enables debugging. Warning: turn it on only if you really need any debugging string in application. Usually it's  better to define this flag in files you need to "hear".DEBUG_FILTER: this flag enables wiping all modes, places etc which are not ready for debugging. Enable this flag only if you are sure that filters are correct.###Library and enviroments requiredFor modern systems:QtCreator if this is UamobiUtilCE source package and any installed Qt 5+ lib.Visual Studio with Qt Visual Tools extension for normal Uamobiutil package and any installed Qt 5+ lib.Android:NDK 19-20+ (tested and compiled on 20.55)SDK 26+ (tested and compiled on 26)Windows:Microsoft Visual Studio 2017-19 (compiled on v.142)Windows SDK 10.0 For older systems:QtCreator 3+ and any installed Qt4.8+ library. Use UamobiUtilCE package because of incompatibility with vs2005.WinCE5.0\6.0Microsoft Visual Studio 2005platform supported SDK (usually Windows Mobile SDK 5.0 is fine). If possible, use platform-provided SDK like HONEYWELL D6X00. Qt 4 binaries for this platform. Note that it is impossible to just google them. Options:Virtual machine winxp_dev contains all binaries for wince5\6 in D:\DevYou still can try building Qt for required platform. Sources are located on same VM. ###Building step by step Qt4 for QtCreator. Wince/WinXp* Open Qt Creator. Export project by opening UamobiUtil.pro file.     * Do not forget, that only UamobiUtilCE source pack has valid .pro file* Assign building kit for the project. Use msvc2005\2008 for WinXp and platform-provided sdk for wince.* Check flags in .pro file. Set INCLUDEPATH += {your qt destination}. Disable QT_VERSION5X.* Build. Do not forget that for proper work you will need visual studio redistributable for your compiler. Qt5 for Visual Studio* Open Visual Studio 2017+    * Install Visual Studio Qt Tools extension    * Add proper version of Qt binaries    * In "project settings" add your qt version destination.     * Check modules _GUI, CORE, WIDGETS, NETWORK, XML_* Check flags in C++ compiler settings. Enable QT_VERSION5X* Build. Do not forget to launch windeployqt.exe after build. Qt5 for QtCreator. Android etc.* Open QtCreator. Export project file.* Assign building kit for target platform    * For android: download Android Studio. In SDK settings select SDK\NDK tools.	* Do not forget to add paths to JRE, NDK at DEVICE settings.    	* Do not forget to choose correct ARM version. Usually armeabi_v7a is ok, sometimes arm64 v8 is required. x86 is rarely used.* Build.#Main construction and architecture notes:This application was concentrated over full crossplatform compatibility. That is why I discourage you of using platform-dependent libraries like <windows.h. If you desperately need something - hide it under #ifdef.  This application is just a client for databases of una.md. All api is described in dataupdateengine.h##StructureThis application is concentrated over tree structure with branch-cutting behavior. This means that you can find logical structure of application by following it's main widget UamobiUtil. Usually it's flow can be described as:  >Login branch - Mode branch - {user selected branch described by mode and submode}   Seleting branch happens in interpretMode method of UamobiUtil widget. Each branch is fully independent - so do it's subwidgets. But note, that this architecture favors to switching to corresponding old subbranch instead of creating a new one. That means that it is usually better to create an inframed branch which will be shown/hidden instead of recreating it every time. Also, this approach can affect allocated memory - do not forget to "cut" branches you do not need.__inframed widget__  This class is the wrapper for normal QWidget, which provides some usefull interfaces, and has own keyfilter that is usefull for key-navigation over application. __Global Settings Object__  In this project global object is not really global - it usually is transmitted in widgets as argument. Main idea is to limit GlobalSettings usage in objects which supposed to be interace only and to provide better understanding of flow. If widget has GAS(Global app settings) object in it - it definitely is using network, or, at least, changes network settings. This object is NOT storing view-changing options.__Element Styles__  In this project is used fully static definition of stylesheets. Header _ElementsStyles.h_ is defining them, and is providing scaling functions. They are creating fonts and sizes using available geometry of main screen.  __legacy__  In header legacy.h are defined some legacy functions that can not be replaced with modern approach. Also there is defined replacement for QScroller.__Abstract selection collections__  For user selection were created some abstract selection classes. You need only provide for them implementation of string representation and indexation, then they will be ready to use.__Processing Overlay__  This header provides an overlay window which is counting remaining time, and then autohides. To use it you must bind an overlay object to application root and then use static functions "show\hideProcessingOverlay".__Controls__Most of the times input elements are not fixed. They are sent from server as a pair name-default. That is why user-input elements must be polymorthic. abs_control class is providing pure interface, so use it for wrapping more complex widgets. __Scaning__ widget family is only containing fixed amount of controls. Fabricate function is suited for creating control from server-provided string. Control type is defining through legacy functions.##Network interactionThis application has 3 different layers of connection. First is __DataUpdatengine__.This engine is handling pure packet delivering. You can call any it's function to make a network request. It will call the object with provided coordinates when it will receive response. This engine DOES NOT parses it's packet, it DOES NOT checks for timeout - it is only encapsulating database functions under http requests.__Network Awaiter__ is the second layer of connection. It usually provides timeout-tracking and one request limitation. It can work both asynchronically or synchronically. You can check it's object if request is awaited, if timeout happened, how much time remains. It's object usually holds both response and error strings from request unitl new request overwrites it.__Request Parser__ is last connection layer.It generally operates over xml documents received through other layers of connections. It is providing package of interpretAs* functions that are tied to common objects. Any of them can try parsing response and will return parsed structure that is ready for usage.##Debugging and tracing moduleThis project contains <debugtrace module that is providing thread-safe engine of writing data in the same log file. Also it provides usefull filtration of prioritized messages. To change it's default behavior you must change construction of static object in it's implementation. Change output mode to differ way it is storing data. Change priority mode to filter out common and annoying debug messages. You can disable it completely by turning max priority - it will just skip messages.